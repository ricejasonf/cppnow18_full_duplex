Generic Full Duplex Messaging

We've seen a lot in the realm of libraries for sockets and protocols for network
communications, but what is there for bringing it all together?

In this presentation, we will utilize generic and functional programming techniques
with a combination of Boost.Asio, Boost.Hana, and other libraries to demonstrate
how to create a transport agnostic interface to a full duplex messaging library.
We will look at how to create concrete implementations using different libraries
providing anywhere from raw TCP to Websockets.

We will also be covering the complex task of managing object lifetimes with asynchronous code,
how the Monad and Comonad concepts can be used to compose network operations, as well as
convenient endpoint composition for adding application level handshakes and data marshalling.

Anyone interested in network programming, or using generic and functional programming in their
libraries will find this presentation useful.

OUTLINE:

Full Duplex Messaging
Endpoint: The Desired Interface
Existing Libraries for Concrete Implementations
  - ASIO
  - Beast
  - SeaSocks
  - [Other]
  - std::thread
  - Identifying Points of Abstraction
Functional Composition
  - Functions
  - Monad
  - Do Notation
  - Comonad
  - [Functional Expression Alias (maybe)]
Dealing with Object Lifetimes
  - Read/Write Handlers and Self Destruction 
  - ASIO and shared_from_this
  - Reducing Unnecessary Allocations
Bringing it all Together
  - Factory Tokens
  - Composing Connection/Handshake Handlers
  - Composing Read/Write Handlers
  - Mapping Events
  - Fun Stuff
